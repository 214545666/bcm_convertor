{"version":3,"sources":["webpack:///./libs/kitten-player/src/ai/classify_ai/diagram/heatmap/index.ts"],"names":["CLASS_COLORS","HeatMap","width","numSamples","containerSelector","replaceMode","userSettings","settings","showAxes","noSvg","xScale","yScale","color_arr","canvas","svg","padding","Object","assign","this","map","color","tmp_scale","scaleLinear","domain","range","clamp","color_range","a","scaleQuantize","select","selectAll","remove","container","append","style","attr","data","discretize","dx","length","dy","Error","context","node","getContext","image","createImageData","y","p","x","value","density","c","rgb","class_index","r","g","b","putImageData","xDomain","yDomain","points","resetRange","updatePoints","updateCircles","xAxis","axisBottom","yAxis","axisLeft","call","filter","selection","enter","d","label","exit"],"mappings":"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","file":"7.cd58f3c977e80dc015d3.js","sourcesContent":["/* https://github.com/tensorflow/playground/blob/master/src/heatmap.ts\n\nCopyright 2016 Google Inc. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n==============================================================================\nCHANGELOG\n\n2019.4\n1. Update d3 from 3.5.16 to 5.9.2 (latest version), use TypeScript 3.3.3, fix syntax errors and reduce implicitly types.\n2. Remove unused parameters and elements here (test data layer, discretize mode, noSvg mode).\n3. Change data structures to handle multi classifications.\n4. Modify constructor, add 'updateRange', 'resetPoints'.\n5. Add 'replaceMode'.\n*/\n\nimport { range } from 'd3-array';\nimport { axisBottom, axisLeft } from 'd3-axis';\nimport { rgb } from 'd3-color';\nimport { select } from 'd3-selection';\nimport { scaleLinear, scaleQuantize } from 'd3-scale';\n\nimport { Example2D, DrawData } from '../../models/defs';\n\nimport './style.css';\n\n/**\n * Colors for drawing preview diagram, indexed by classification.\n */\nexport const CLASS_COLORS = [\n  '#0057FF',\n  '#FF9948',\n  '#3DD1AE',\n  '#FF4B4B',\n];\n\nexport interface HeatMapSettings {\n  showAxes?:boolean;\n  noSvg?:boolean;\n}\n\n/** Number of different shades (colors) when drawing a gradient heatmap */\nconst NUM_SHADES = 30;\n\nconst AXES_PADDING = 20;\n\n/**\n * Draws a heatmap using canvas. Used for showing the learned decision\n * boundary of the classification algorithm. Can also draw data points\n * using an svg overlayed on top of the canvas heatmap.\n */\nexport class HeatMap {\n  private settings:HeatMapSettings = {\n    showAxes: true,\n    noSvg: false,\n  };\n  private xScale:d3.ScaleLinear<number, number>;\n  private yScale:d3.ScaleLinear<number, number>;\n  private numSamples:number;\n  private color_arr:d3.ScaleQuantize<string>[];\n  private canvas:d3.Selection<HTMLCanvasElement, {}, HTMLElement, any>;\n  private svg:d3.Selection<SVGElement, {}, HTMLElement, any>;\n\n  private width:number;\n  private padding:number;\n\n  constructor(\n    width:number, numSamples:number, containerSelector:string, replaceMode:boolean = false,\n    userSettings?:HeatMapSettings) {\n    // overwrite the defaults with the user-specified settings.\n    userSettings && Object.assign(this.settings, userSettings);\n\n    this.numSamples = numSamples;\n    this.width = width;\n    this.padding = this.settings.showAxes ? AXES_PADDING : 0;\n\n    // Get a range of colors.\n    this.color_arr = CLASS_COLORS.map((color) => {\n      const tmp_scale = scaleLinear<string>()\n        .domain([0, 1])\n        .range(['#ffffff', color])\n        .clamp(true);\n      // Due to numerical error, we need to specify\n      // d3.range(0, end + small_epsilon, step)\n      // in order to guarantee that we will have end/step entries with\n      // the last element being equal to end.\n      const color_range = range(0, 1 + 1E-9, 1 / NUM_SHADES).map((a) => {\n        return tmp_scale(a);\n      });\n      return scaleQuantize<string>()\n        .domain([0, 1])\n        .range(color_range);\n    });\n\n    if (replaceMode) {\n      // Clear all data in the selected container before init a new heatmap.\n      select(containerSelector).selectAll('*').remove();\n    }\n\n    const container = select(containerSelector).append('div')\n      .style('width', this.width + 'px')\n      .style('height', this.width + 'px')\n      .style('position', 'relative');\n\n    this.canvas = container.append('canvas')\n      .attr('width', numSamples)\n      .attr('height', numSamples)\n      .style('width', (this.width - 2 * this.padding) + 'px')\n      .style('height', (this.width - 2 * this.padding) + 'px')\n      .style('position', 'absolute')\n      .style('top', `${this.padding}px`)\n      .style('left', `${this.padding}px`);\n\n    if (this.settings.noSvg) { return; }\n    this.svg = container.append('svg')\n      .attr('width', this.width)\n      .attr('height', this.width)\n      .style('position', 'absolute')\n      .style('top', '0')\n      .style('left', '0')\n      .append('g')\n      .attr('transform', `translate(${this.padding},${this.padding})`);\n\n    // Append heatmap after axes so that dots are always upper the coordinates\n    this.svg.append('g').attr('class', 'train');\n  }\n\n  updateBackground(data:DrawData[][], discretize:boolean = false) : void {\n    const dx = data[0].length;\n    const dy = data.length;\n\n    if (dx !== this.numSamples || dy !== this.numSamples) {\n      throw new Error(\n        'The provided data matrix must be of size ' +\n        'numSamples X numSamples');\n    }\n\n    // Compute the pixel colors; scaled by CSS.\n    const context = (this.canvas.node() as HTMLCanvasElement).getContext('2d');\n    if (!context) { return; }\n    const image = context.createImageData(dx, dy);\n\n    for (let y = 0, p = -1; y < dy; ++y) {\n      for (let x = 0; x < dx; ++x) {\n        const value = data[x][y];\n        if (discretize) {\n          value.density = (value.density >= 0 ? 1 : -1);\n        }\n        const c = rgb(this.color_arr[value.class_index](value.density));\n        image.data[++p] = c.r;\n        image.data[++p] = c.g;\n        image.data[++p] = c.b;\n        image.data[++p] = 160;\n      }\n    }\n    context.putImageData(image, 0, 0);\n  }\n\n  resetPoints(xDomain:[number, number], yDomain:[number, number], points:Example2D[]) {\n    this.resetRange(xDomain, yDomain);\n    this.svg.select('g.train').selectAll('circle').remove();\n    this.updatePoints(points);\n  }\n\n  private updatePoints(points:Example2D[]) : void {\n    if (this.settings.noSvg) {\n      throw Error(\"Can't add points since noSvg=true\");\n    }\n    this.updateCircles(this.svg.select('g.train'), points);\n  }\n\n  private resetRange(xDomain:[number, number], yDomain:[number, number]) {\n    // d3.scaleLinear: projection from domain to range\n    this.xScale = scaleLinear()\n      .domain(xDomain)\n      .range([0, this.width - 2 * this.padding]);\n\n    this.yScale = scaleLinear()\n      .domain(yDomain)\n      .range([this.width - 2 * this.padding, 0]);\n\n    if (this.settings.showAxes) {\n      const xAxis = axisBottom(this.xScale);\n      const yAxis = axisLeft(this.yScale);\n\n      // Clear existing axes and set new ones\n      this.svg.selectAll('.axis').remove();\n      this.svg.append('g')\n        .attr('class', 'x axis')\n        .attr('transform', `translate(0,${this.width - 2 * this.padding})`)\n        .call(xAxis);\n\n      this.svg.append('g')\n        .attr('class', 'y axis')\n        .call(yAxis);\n    }\n  }\n\n  private updateCircles(container:d3.Selection<SVGElement, {}, HTMLElement, any>, points:Example2D[]) {\n    // Keep only points that are inside the bounds.\n    const xDomain = this.xScale.domain();\n    const yDomain = this.yScale.domain();\n    points = points.filter((p) => {\n      return p.x >= xDomain[0] && p.x <= xDomain[1]\n        && p.y >= yDomain[0] && p.y <= yDomain[1];\n    });\n\n    // Attach data to initially empty selection.\n    const selection = container.selectAll('circle').data(points);\n\n    // Insert elements to match length of points array\n    // and update points to be in the correct position.\n    selection.enter().append('circle')\n      .attr('r', 3)\n      .style('stroke', '#fff')\n      .style('stroke-width', 0.7)\n      .attr('cx', (d:Example2D) => this.xScale(d.x))\n      .attr('cy', (d:Example2D) => this.yScale(d.y))\n      .style('fill', (d:Example2D) => this.color_arr[d.label](1));\n\n    // Remove points if the length has gone down.\n    selection.exit().remove();\n  }\n}  // Close class HeatMap."],"sourceRoot":""}